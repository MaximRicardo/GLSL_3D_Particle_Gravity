#version 430 core

layout (std430, binding=0) buffer particle_positions_buffer {
    vec4 particle_positions[];
};

layout (std430, binding=1) buffer particle_lighting_buffer {
    float particle_lighting[];
};

layout (std430, binding=2) buffer particle_velocities_buffer {
    vec4 particle_velocities[];
};

layout (std430, binding=4) readonly buffer particle_radii_buffer {
    float particle_radii[];
};

uniform float particle_mass;
uniform float particle_light_strength;

uniform float G;

uniform float delta_time;

uniform int n_particles;

uniform vec3 cam_pos;

uniform bool paused;

const float PI = 3.141592;
const float epsilon = 0.1f;

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void gravity(int thread_idx, int other_idx, inout vec3 acceleration) {

    bool is_same = thread_idx == other_idx;
    float dist = distance(particle_positions[thread_idx].xyz, particle_positions[other_idx].xyz) + epsilon;

    float f = particle_mass*G*pow(dist, -2.0);
    vec3 dir = normalize(particle_positions[other_idx].xyz - particle_positions[thread_idx].xyz + vec3(float(is_same), 0.0, 0.0));

    acceleration.xyz = dir*f*float(!is_same) + acceleration.xyz;  //MAD >:(

}

void compute_light(int thread_idx, int i, float cam_dist) {

    float dist_squared = pow(distance(particle_positions[thread_idx].xyz, particle_positions[i].xyz), 2.0);
    if (dist_squared != 0.0 && i != thread_idx) {
        float other_visible_radius = clamp(particle_radii[i] * cam_dist*(1.0/250.0), particle_radii[i]*(1.0/10.0), particle_radii[i]);
        particle_lighting[thread_idx] = (2.0*PI*pow(other_visible_radius,2.0))*particle_light_strength / dist_squared + particle_lighting[thread_idx];
    }

}

void main() {

    int thread_idx = int(gl_GlobalInvocationID.x);
    if (thread_idx >= n_particles) return;

    float cam_dist = distance(cam_pos.xyz, particle_positions[thread_idx].xyz);

    particle_lighting[thread_idx] = pow(particle_radii[thread_idx],2.0)*particle_light_strength;
    vec3 acceleration = vec3(0.0, 0.0, 0.0);

    if (!paused) {
        for (int i = 0; i < n_particles; i++) {
            gravity(thread_idx, i, acceleration); //Not doing this if the program is paused lowers the fps by about 5 - 10 on my machine.
            
            compute_light(thread_idx, i, cam_dist);
        }
    }
    else {
        for (int i = 0; i < n_particles; i++) {
            compute_light(thread_idx, i, cam_dist);
        }
    }

    //Apply acceleration and velocity
    if (!paused) {
        particle_velocities[thread_idx].xyz += acceleration.xyz*delta_time;
        particle_positions[thread_idx].xyz += particle_velocities[thread_idx].xyz*delta_time;
    }
    
}
